.section .text      # 指明这是一个代码段（text section），可执行代码通常放在这里。

.global _entry      # 声明 _entry 符号为全局可见。
                    # 这是内核的第一个执行点，引导加载程序（boot loader）会跳转到这里。
                    # 在 RISC-V 的 QEMU 模拟环境中，通常是 0x80000000 物理地址。

_entry:             # _entry 标签定义了代码的入口点。
	la sp,stack0    # 1. 加载地址：将标签 `stack0` 的地址加载到堆栈指针寄存器 `sp` (x2) 中。
                    #    `stack0` 通常定义在链接脚本中，指向所有 CPU 核心共享的初始堆栈空间（比如内核启动前的临时栈）。
                    #    这是为了在进入 C 代码之前，给当前的 CPU 核心（Hart）一个可用的堆栈。
                    #    主要目的：让每个 CPU 核心拥有独立的、不重叠的堆栈空间。

	li a0,1024*4    # 2. 加载立即数：将 1024 * 4 的值（即 4096，通常是一个页的大小）加载到寄存器 `a0` 中。
                    #    这代表了每个 CPU 核心的堆栈大小（或分配单位）。

	csrr a1,mhartid # 3. CSR 读取：从 `mhartid` 控制和状态寄存器（CSR）读取当前 CPU 核心的唯一 ID (hartid)。
                    #    `mhartid` 寄存器存储了当前 Hart（硬件线程）的整数标识符。例如，第一个核心是0，第二个是1，以此类推。
                    #    将读取到的 hartid 存入寄存器 `a1` 中。

	addi a1,a1,1    # 4. 加立即数：将寄存器 `a1` 的值（hartid）加 1，结果存回 `a1`。
                    #    目的：为了避免 hartid 为 0 时，堆栈偏移量为 0，导致所有核心都使用相同的起始堆栈地址。
                    #    确保每个核心的偏移量至少为 `1 * (1024*4)`，从而分配到不同的堆栈区域。
                    #    例如：hart0 对应偏移量为 1 * 4096；hart1 对应偏移量为 2 * 4096。

	mul a0,a0,a1    # 5. 乘法：将寄存器 `a0` 的值（每个核心的堆栈大小单位）与 `a1` 的值（hartid+1）相乘。
                    #    结果存回 `a0`。
                    #    计算公式：a0 = (每个核心的堆栈大小) * (hartid + 1)
                    #    这实际上计算出了当前 CPU 核心应该相对于 `stack0` 起始地址的**总偏移量**。
                    #    这样，每个核心就会拥有一个不重叠的堆栈段。

	add sp,sp,a0    # 6. 加法：将 `sp` 寄存器（当前指向 `stack0`）的值加上 `a0` 的值（计算出的偏移量）。
                    #    结果存回 `sp`。
                    #    最终 `sp` 会指向当前 CPU 核心在整个堆栈空间中为其分配的**独立堆栈区域的末尾**（因为堆栈通常向下增长）。
                    #    例如：
                    #    - hart0: sp = stack0 + (1 * 4096)
                    #    - hart1: sp = stack0 + (2 * 4096)
                    #    - ...

	call start      # 7. 调用：跳转到 C 语言的 `start` 函数。
                    #    这是从汇编代码过渡到 C 语言执行的关键点。
                    #    `start` 函数将在设置好的独立堆栈上开始执行 C 代码。

spin:               # spin 标签定义了一个无限循环。
	j spin          # 8. 无条件跳转：跳转回 `spin` 标签自身。
                    #    目的：如果 `call start` 函数因为某种原因返回了（这在内核中不应该发生，因为内核会一直运行），
                    #    那么 CPU 就会陷入这个无限循环，避免执行到未定义的区域。
                    #    这是一种简单的错误处理或防止意外行为的机制。
