// // 内核构建过程：
// 1. 源代码 (如 entry.S, main.c)：构成内核功能的指令和逻辑。
//    它们是操作系统各个部分的“积木图纸”。
// 2. 编译 (gcc -c...)：编译器将源代码转换为独立的“目标文件” (.o)。
//    每个 .o 文件是编译后的代码模块，尚未组合。
// 3. 链接器 (ld 命令)：链接器负责将所有 .o 目标文件组合成一个完整的可执行程序。
//    它将独立的模块“组装”起来。
// 4. 链接脚本 (kernel.ld) 的作用：
//    这是链接器组装时的“总建筑蓝图”或“组装说明书”。
//    它定义了内核代码和数据在物理内存中的精确布局、起始地址和对齐方式。
// 5. 构建出内核的完整映像 (kernel.elf)：
//    链接器依据链接脚本，将所有代码和数据按指定地址和顺序放置。
//    最终生成一个单一的、可由引导程序直接加载和执行的内核映像文件。

// 为什么需要链接脚本：
// 硬件约定：CPU启动需从固定物理地址加载代码。
// OS需求：内核需精确控制内存布局以实现内存管理和保护。
// 分段保护：不同数据类型放置在不同段以设置访问权限，提高安全性。

OUTPUT_ARCH( "riscv" ) # 指定目标架构为 RISC-V。
ENTRY( _entry )        # 指定程序的入口点为 `_entry` 符号。

SECTIONS                 # 定义输出文件中的内存段布局。
{
  /*
   * 确保内核入口点位于 0x80000000 物理地址，
   * 这是 QEMU 启动内核时的约定。
   */
  . = 0x80000000;          # 设置当前链接地址为 0x80000000。

  .text : {                # 定义代码段（可执行指令）。
    *(.text .text.*)       # 包含所有输入目标文件中的代码段。
    . = ALIGN(0x1000);     # 将当前地址对齐到 4KB 页面边界。
    _trampoline = .;       # 定义 `_trampoline` 符号为当前地址（跳板页的起始）。
    *(trampsec)            # 包含跳板代码段。
    . = ALIGN(0x1000);     # 再次对齐到 4KB 页面边界。
    /* ASSERT(. - _trampoline == 0x1000, "error: trampoline larger than one page"); */
    PROVIDE(etext = .);    # 定义 `etext` 符号为代码段的结束地址。
  }

  .rodata : {              # 定义只读数据段（如常量字符串）。
    . = ALIGN(16);         # 对齐到 16 字节。
    *(.srodata .srodata.*) # 包含所有小的只读数据段。
    . = ALIGN(16);         # 再次对齐。
    *(.rodata .rodata.*)   # 包含所有只读数据段。
  }

  .data : {                # 定义已初始化数据段（已初始化的全局变量）。
    . = ALIGN(16);         # 对齐到 16 字节。
    *(.sdata .sdata.*)     # 包含所有小的已初始化数据段。
    . = ALIGN(16);         # 再次对齐。
    *(.data .data.*)       # 包含所有已初始化数据段。
  }

  .bss : {                 # 定义未初始化数据段（未初始化的全局变量，在启动时清零）。
    . = ALIGN(16);         # 对齐到 16 字节。
    *(.sbss .sbss.*)       # 包含所有小的未初始化数据段。
    . = ALIGN(16);         # 再次对齐。
    *(.bss .bss.*)         # 包含所有未初始化数据段。
  }

  PROVIDE(end = .);        # 定义 `end` 符号为所有内核段的结束地址。
}
