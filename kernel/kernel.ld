/* 1.  **代码（`entry.S`, `main.c`, `trap.c` 等）**：这些是你手头的**乐高积木图纸**。每一张图纸都告诉你怎么拼一个部分（比如，一张图纸教你怎么拼墙，另一张教你怎么拼屋顶）。 */
/**/
/* 2.  **编译（`gcc -c ...`）**：你把这些图纸（源代码）交给一个乐高工厂的**工人（编译器）**。工人根据每张图纸，把对应的积木部分（`entry.o`, `main.o`, `trap.o` 等）拼好，但它们还是独立的零件，没有组装成完整的房子。这些 `.o` 文件就是你的**目标文件**。 */
/**/
/* 3.  **链接器（`ld` 命令）**：现在，你有了很多拼好的独立积木零件（目标文件 `.o`），你需要把它们**组装成一个完整的房子**。这个组装过程就是**链接**，而负责组装的工人就是**链接器**。 */
/**/
/* 4.  **链接脚本（这个文件 `kernel.ld`）**： */
/*     *   链接器在组装零件的时候，不能随便拼。它需要一个**总体的“建筑蓝图”或“组装说明书”**，告诉它： */
/*         *   “客厅（`_entry`）必须放在地基（`0x80000000`）的这个位置。” */
/*         *   “卧室（`.text` 段）应该紧挨着客厅放。” */
/*         *   “厨房（`.data` 段）和卫生间（`.bss` 段）分别放在房子的哪个区域。” */
/*         *   “屋顶上的天线（`_trampoline`）要精确地对齐到某个特定位置。” */
/*     *   **这个“建筑蓝图”就是链接脚本。** 它告诉链接器： */
/*         *   **内存布局：** 房子各个部分在“地皮”（物理内存）上的具体位置和顺序。 */
/*         *   **起始地址：** 整个房子从地皮的哪个具体位置（`0x80000000`）开始建造。 */
/*         *   **对齐方式：** 某些特殊结构（如 `_trampoline`）必须精确地放在地皮上的某个网格点（比如 4KB 对齐）。 */
/**/
/* 5.  **构建出内核的完整映像**： */
/*     *   当链接器根据链接脚本的指示，把所有的乐高积木零件（代码、数据）按照特定的内存地址和顺序组装起来后，它就形成了一个**完整的、可以运行的“乐高房子”**。 */
/*     *   这个“乐高房子”在计算机世界里，就是你的 **xv6 内核映像（Kernel Image）**。它是一个单一的文件（通常没有后缀名，或者 `.elf`），包含了操作系统启动和运行所需的所有指令和数据。 */
/*     *   这个映像文件就是 QEMU (你的虚拟机) 需要加载到内存中，并开始执行的那个“程序”。 */
/**/
/* ### 为什么需要这么复杂？ */
/**/
/* *   **硬件约定：** 计算机硬件（CPU、内存控制器）在启动时，通常会从一个固定的、预设的物理内存地址（比如 `0x80000000`）去加载和执行第一个指令。链接脚本的任务就是确保你的内核代码正好被放置在这个地址。 */
/* *   **操作系统需求：** 操作系统内核需要非常精确地控制自己和用户程序在内存中的位置。它需要知道代码在哪里、数据在哪里、空闲内存从哪里开始，以便进行内存管理、进程切换等。链接脚本提供了这种精确的控制。 */
/* *   **分段和保护：** 将代码、只读数据、可读写数据、未初始化数据分别放置在不同的“段”中，有助于操作系统设置不同的内存访问权限（例如，代码段可执行但不可写，只读数据段可读但不可写），从而提高系统的安全性和稳定性。 */
/**/
/* 简而言之，链接脚本是告诉计算机“你的操作系统应该长什么样，以及它在内存中应该放在哪里”的精确说明书。 */

OUTPUT_ARCH( "riscv" ) # 指定目标架构为 RISC-V。
ENTRY( _entry )        # 指定程序的入口点为 `_entry` 符号。

SECTIONS                 # 定义输出文件中的内存段布局。
{
  /*
   * 确保内核入口点位于 0x80000000 物理地址，
   * 这是 QEMU 启动内核时的约定。
   */
  . = 0x80000000;          # 设置当前链接地址为 0x80000000。

  .text : {                # 定义代码段（可执行指令）。
    *(.text .text.*)       # 包含所有输入目标文件中的代码段。
    . = ALIGN(0x1000);     # 将当前地址对齐到 4KB 页面边界。
    _trampoline = .;       # 定义 `_trampoline` 符号为当前地址（跳板页的起始）。
    *(trampsec)            # 包含跳板代码段。
    . = ALIGN(0x1000);     # 再次对齐到 4KB 页面边界。
    /* ASSERT(. - _trampoline == 0x1000, "error: trampoline larger than one page"); */
    PROVIDE(etext = .);    # 定义 `etext` 符号为代码段的结束地址。
  }

  .rodata : {              # 定义只读数据段（如常量字符串）。
    . = ALIGN(16);         # 对齐到 16 字节。
    *(.srodata .srodata.*) # 包含所有小的只读数据段。
    . = ALIGN(16);         # 再次对齐。
    *(.rodata .rodata.*)   # 包含所有只读数据段。
  }

  .data : {                # 定义已初始化数据段（已初始化的全局变量）。
    . = ALIGN(16);         # 对齐到 16 字节。
    *(.sdata .sdata.*)     # 包含所有小的已初始化数据段。
    . = ALIGN(16);         # 再次对齐。
    *(.data .data.*)       # 包含所有已初始化数据段。
  }

  .bss : {                 # 定义未初始化数据段（未初始化的全局变量，在启动时清零）。
    . = ALIGN(16);         # 对齐到 16 字节。
    *(.sbss .sbss.*)       # 包含所有小的未初始化数据段。
    . = ALIGN(16);         # 再次对齐。
    *(.bss .bss.*)         # 包含所有未初始化数据段。
  }

  PROVIDE(end = .);        # 定义 `end` 符号为所有内核段的结束地址。
}
